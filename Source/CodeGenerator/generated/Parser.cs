// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2008
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.3.6
// Machine:  COREDUO
// DateTime: 27.1.2010 23:20:06
// UserName: Jakub
// Input file <generators\Parser.y>

// options: babel no-lines gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using linqtoweb.CodeGenerator.AST;

namespace linqtoweb.CodeGenerator
{
public enum Tokens {
    error=1,EOF=2,CLASS=3,IDENTIFIER=4,FOREACH=5,LPAREN=6,
    RPAREN=7,LBRACE=8,RBRACE=9,LBRACKET=10,RBRACKET=11,STRINGVAL=12,
    INTEGERVAL=13,DOUBLEVAL=14,OP_PLUS=15,OP_MINUS=16,OP_MUL=17,OP_DIV=18,
    OP_ASSIGN=19,COMMA=20,SEMICOLON=21,WHITESPACE=22,COMMENT=23};

public struct ValueType
{
	public Expression node;
}
// Abstract base class for GPLEX scanners
public abstract class ScanBase : AbstractScanner<ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }

  protected abstract int CurrentSc { get; set; }
  //
  // Override the virtual EolState property if the scanner state is more
  // complicated then a simple copy of the current start state ordinal
  //
  public virtual int EolState { get { return CurrentSc; } set { CurrentSc = value; } }
}

// Interface class for 'colorizing' scanners
public interface IColorScan {
  void SetSource(string source, int offset);
  int GetNext(ref int state, out int start, out int end);
}

public class Parser: ShiftReduceParser<ValueType, LexLocation>
{
#pragma warning disable 649
    private Dictionary<int, string> aliasses;
#pragma warning restore 649

  protected override void Initialize()
  {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);

    this.InitStateTable(8);
    AddState(0,new State(new int[]{3,4},new int[]{-1,1,-3,3}));
    AddState(1,new State(new int[]{2,2}));
    AddState(2,new State(-1));
    AddState(3,new State(-2));
    AddState(4,new State(new int[]{4,5}));
    AddState(5,new State(new int[]{8,6}));
    AddState(6,new State(new int[]{9,7}));
    AddState(7,new State(-3));

    Rule[] rules=new Rule[4];
    rules[1]=new Rule(-2, new int[]{-1,2});
    rules[2]=new Rule(-1, new int[]{-3});
    rules[3]=new Rule(-3, new int[]{3,4,8,9});
    this.InitRules(rules);

    this.InitNonTerminals(new string[] {"", "init", "$accept", "classdecl", });
  }

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // init -> classdecl
{
					Ast = new GlobalCode();
				}
        break;
      case 3: // classdecl -> CLASS, IDENTIFIER, LBRACE, RBRACE
{  }
        break;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }


    public Parser(Scanner scanner) : base(scanner) { }
    
    public GlobalCode Ast {get;private set;}

}
}
