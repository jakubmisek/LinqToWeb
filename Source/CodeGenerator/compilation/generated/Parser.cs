// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2008
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.3.6
// Machine:  COREDUO
// DateTime: 26.1.2010 23:06:01
// UserName: Jakub
// Input file <compilation\generators\Parser.y>

// options: babel no-lines gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;

namespace linqtoweb.CodeGenerator.compilation
{
public enum Tokens {error=42,
    EOF=43,DIGIT=44,OPERATOR=45};

public struct ValueType
{
	public object Object;
	public LexLocation Pos;
}
// Abstract base class for GPLEX scanners
public abstract class ScanBase : AbstractScanner<ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }

  protected abstract int CurrentSc { get; set; }
  //
  // Override the virtual EolState property if the scanner state is more
  // complicated then a simple copy of the current start state ordinal
  //
  public virtual int EolState { get { return CurrentSc; } set { CurrentSc = value; } }
}

// Interface class for 'colorizing' scanners
public interface IColorScan {
  void SetSource(string source, int offset);
  int GetNext(ref int state, out int start, out int end);
}

public class Parser: ShiftReduceParser<ValueType, LexLocation>
{
#pragma warning disable 649
    private Dictionary<int, string> aliasses;
#pragma warning restore 649

  protected override void Initialize()
  {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);

    this.InitStateTable(11);
    AddState(0,new State(new int[]{40,6,44,10},new int[]{-1,1,-3,3,-4,9}));
    AddState(1,new State(new int[]{43,2}));
    AddState(2,new State(-1));
    AddState(3,new State(new int[]{45,4,43,-2}));
    AddState(4,new State(new int[]{40,6,44,10},new int[]{-3,5,-4,9}));
    AddState(5,new State(-4));
    AddState(6,new State(new int[]{40,6,44,10},new int[]{-3,7,-4,9}));
    AddState(7,new State(new int[]{41,8,45,4}));
    AddState(8,new State(-3));
    AddState(9,new State(-5));
    AddState(10,new State(-6));

    Rule[] rules=new Rule[7];
    rules[1]=new Rule(-2, new int[]{-1,43});
    rules[2]=new Rule(-1, new int[]{-3});
    rules[3]=new Rule(-3, new int[]{40,-3,41});
    rules[4]=new Rule(-3, new int[]{-3,45,-3});
    rules[5]=new Rule(-3, new int[]{-4});
    rules[6]=new Rule(-4, new int[]{44});
    this.InitRules(rules);

    this.InitNonTerminals(new string[] {"", "init", "$accept", "expr", "number", 
      });
  }

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // init -> expr
{
					Result = ValueStack[ValueStack.Depth-1].Object;
				}
        break;
      case 3: // expr -> '(', expr, ')'
{
                    CurrentSemanticValue.Object = ValueStack[ValueStack.Depth-2].Object;
                    CurrentSemanticValue.Pos = LocationStack[LocationStack.Depth-3].Merge(LocationStack[LocationStack.Depth-1]);
                }
        break;
      case 4: // expr -> expr, OPERATOR, expr
{
                    CurrentSemanticValue.Object = null;//new OP($2.Object, $1.Object, $3.Object);
                    CurrentSemanticValue.Pos = LocationStack[LocationStack.Depth-3].Merge(LocationStack[LocationStack.Depth-1]);
                }
        break;
      case 6: // number -> DIGIT
{
                    CurrentSemanticValue.Object = ValueStack[ValueStack.Depth-1].Object;
                    CurrentSemanticValue.Pos = LocationStack[LocationStack.Depth-1];
                }
        break;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }


    public Parser(Scanner scanner) : base(scanner) { }
    
    public object Result {get;private set;}

}
}
